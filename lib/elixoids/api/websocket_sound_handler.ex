defmodule Elixoids.Api.WebsocketSoundHandler do
  @moduledoc """
  Websocket Handler. Queries the game state at 12fps
  and publishes the sounds to the subscriber.
  """

  alias Elixoids.Api.Sound.Protocol, as: SoundProtocol
  import Logger

  @fps 12
  @ms_between_frames div(1000, @fps)
  @opts %{idle_timeout: 60 * 60 * 1000}

  @behaviour :cowboy_handler

  def init(req = %{headers: %{"accept" => "application/octet-stream"}}, _opts) do
    state = %{encode: &encode_protocol/1, events: []}
    {:cowboy_websocket, req, state, @opts}
  end

  def init(req, _opts) do
    state = %{encode: &encode_json/1, events: []}
    {:cowboy_websocket, req, state, @opts}
  end

  @doc """
  Client connects here. State is the set of explosions sent to the client recently.
  """
  def websocket_init(state) do
    {:ok, _pid} = Elixoids.News.subscribe(0)
    [:ws_connection, :audio] |> inspect |> info()
    :erlang.start_timer(@ms_between_frames, self(), [])
    {:ok, state}
  end

  def websocket_terminate(_reason, _req, _state) do
    [:ws_disconnect, :audio] |> inspect |> info()
    :ok
  end

  def websocket_handle(_data, state) do
    {:ok, state}
  end

  # Heatbeat to push the state
  def websocket_info({:timeout, _ref, _}, state = %{events: []}) do
    :erlang.start_timer(@ms_between_frames, self(), [])
    {:ok, state}
  end

  # Perodically push the game state we have accumulated to the client.
  def websocket_info({:timeout, _ref, _}, state = %{encode: encode}) do
    :erlang.start_timer(@ms_between_frames, self(), [])
    encode.(state)
  end

  # Keep the sound event generated by the game
  def websocket_info({:audio, event}, state = %{events: events}) do
    {:ok, %{state | events: [event | events]}}
  end

  def websocket_info(_, state) do
    {:ok, state}
  end

  defp encode_json(state = %{events: events}),
    do: {:reply, {:text, format(events)}, %{state | events: []}}

  defp format(state) do
    ordered_events = Enum.reverse(state)

    case Jason.encode(ordered_events) do
      {:ok, message} -> message
    end
  end

  defp encode_protocol(state = %{events: events}),
    do: {:reply, {:binary, SoundProtocol.encode(events)}, %{state | events: []}}
end
